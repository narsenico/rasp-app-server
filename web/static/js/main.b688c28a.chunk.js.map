{"version":3,"sources":["utility.js","components/calendar/Calendar.js","components/weather/WeatherIconsHelper.js","components/weather/Weather.js","components/wastecollection/WasteCollection.js","components/app/App.js","serviceWorker.js","index.js"],"names":["useInterval","callback","delay","timeout","fn","useRef","useEffect","current","hnd","setTimeout","clearTimeout","setInterval","clearInterval","formatDate","date","format","dfFormat","locale","it","shortTime","Date","now","shortDate","humanDate","today","tomorrow","addDays","ref","parseDate","dfParse","Calendar","useState","event","setEvent","time","setTime","longTime","a","axios","get","process","res","events","data","length","start","end","summary","description","location","dtStart","dtEnd","console","error","className","getHourlyIconClassName","hourly","sunrise","sunset","index","weather","getTime","toFixed","id","Weather","forecast","setForecast","cronTime","runOnInit","job","CronJob","undefined","stop","useCron","icon","items","slice","map","hour","item","key","WASTE_DESCR","P","C","U","V","S","WasteCollection","waste","setWaste","title","split","wt","type","itmes","App","Boolean","window","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.b688c28a.chunk.js","sourcesContent":["import { useRef, useEffect } from 'react';\nimport { format as dfFormat, parse as dfParse, addDays } from 'date-fns';\nimport { it } from 'date-fns/locale';\nimport { CronJob } from 'cron';\n\n/**\n * Hook react per setInterval\n *\n * @param {Function} callback funzione da eseguire ad ogni intervallo\n * @param {Number} delay millisecondi di attesa per la prima esecuzione\n * @param {Number} timeout timeout internvallo in millisecondi\n */\nexport const useInterval = (callback, delay, timeout) => {\n    const fn = useRef();\n\n    useEffect(() => {\n        fn.current = callback;\n    }, [callback]);\n\n    useEffect(() => {\n        let hnd;\n        if (delay < timeout) {\n            hnd = setTimeout(fn.current, delay);\n        }\n        return () => {\n            clearTimeout(hnd);\n        };\n    }, [fn, delay, timeout]);\n\n    useEffect(() => {\n        const hnd = setInterval(fn.current, timeout);\n        return () => {\n            clearInterval(hnd);\n        };\n    }, [fn, timeout]);\n};\n\n/**\n * Hook per cron.\n * Se l'opzione runOnInit è true la callback viene chiamata la prima\n * volta immediatamente.\n *\n * @param {String} cronTime indica quando scatenare la callback, usando la sintassi cron\n * @param {Function} callback callback chiamata\n * @param {Object} options opzioni\n */\nexport const useCron = (cronTime, callback, { runOnInit }) => {\n    const fn = useRef();\n\n    useEffect(() => {\n        fn.current = callback;\n    }, [callback]);\n\n    useEffect(() => {\n        const job = new CronJob(\n            cronTime,\n            fn.current,\n            null,\n            false,\n            undefined,\n            undefined,\n            runOnInit\n        );\n        job.start();\n        return () => job.stop();\n    }, [cronTime, runOnInit]);\n};\n\nexport const formatDate = (date, format) => {\n    return dfFormat(date, format, { locale: it });\n};\n\nexport const shortTime = (date = Date.now()) => {\n    return formatDate(date, 'HH:mm');\n};\n\nexport const longTime = (date = Date.now()) => {\n    return formatDate(date, 'HH:mm:ss');\n};\n\nexport const shortDate = (date = Date.now()) => {\n    return formatDate(date, 'EEE, dd MMM');\n};\n\nexport const longDate = (date = Date.now()) => {\n    return formatDate(date, 'EEEE, dd MMMM yyyy');\n};\n\nexport const humanDate = (date = Date.now()) => {\n    const today = formatDate(Date.now(), 'yyyyMMdd');\n    const tomorrow = formatDate(addDays(Date.now(), 1), 'yyyyMMdd');\n    const ref = formatDate(date, 'yyyyMMdd');\n    return ref === today\n        ? 'Oggi'\n        : ref === tomorrow\n        ? 'Domani'\n        : shortDate(date);\n};\n\nexport const parseDate = (date, format = 'yyyyMMdd') => {\n    return dfParse(date, format, 0);\n};\n","import React, { useState } from 'react';\nimport axios from 'axios';\n\nimport { useInterval, humanDate, shortTime, longTime } from '../../utility';\n\nimport './Calendar.css';\n\nconst SERVER_BASE_URL = process.env.REACT_APP_SERVER_BASE_URL;\nconst INTERVAL = 60000;\n\n/**\n * Componente che mostra il prossimo evento del calendario.\n */\nfunction Calendar() {\n    const [event, setEvent] = useState();\n    const [time, setTime] = useState();\n\n    useInterval(\n        () => {\n            setTime(longTime());\n        },\n        1000,\n        1000\n    );\n\n    useInterval(\n        () => {\n            (async () => {\n                try {\n                    const res = await axios.get(\n                        `${SERVER_BASE_URL}/calendar/events`\n                    );\n                    const events = res.data;\n                    // console.log(events);\n                    if (events.length === 0) {\n                        setEvent(null);\n                    } else {\n                        const {\n                            start,\n                            end,\n                            summary,\n                            description,\n                            location,\n                        } = events[0];\n                        const dtStart = new Date(start);\n                        const dtEnd = new Date(end);\n                        setEvent({\n                            start: `${humanDate(dtStart)} ${shortTime(\n                                dtStart\n                            )}`,\n                            end: `${humanDate(dtEnd)} ${shortTime(dtEnd)}`,\n                            summary,\n                            description,\n                            location,\n                        });\n                    }\n                } catch (e) {\n                    // TODO: gestire mancata autorizzazione\n                    console.error(e);\n                }\n            })();\n        },\n        0,\n        INTERVAL\n    );\n\n    return (\n        <div className=\"calendar-event\">\n            <div className=\"time\">{time}</div>\n            {event ? (\n                <>\n                    <div className=\"start\">{event.start}</div>\n                    <div className=\"end\">{event.end}</div>\n                    <div className=\"summary\">{event.summary}</div>\n                    <div className=\"descr\">{event.description}</div>\n                    <div className=\"location\">{event.location}</div>\n                </>\n            ) : (\n                <div className=\"descr\">Non hai un cazzo da fare</div>\n            )}\n        </div>\n    );\n}\n\nexport default Calendar;\n","/**\n * Ritorna la classe css per l'icona da usare in base alle informazioni\n * contenute in hourly, che rappresenta il meteo per una precisa ora.\n *\n * hourly può contenere diversi oggetti weather, considero quello indicato da index.\n *\n * @param {any} hourly\n * @param {String}  sunrise alba come stringa UTC\n * @param {String}  sunset  tramonto come string UTC\n * @param {Number}  index   indice di hourly.weather\n */\nexport const getHourlyIconClassName = (hourly, sunrise, sunset, index = 0) => {\n    const weather = hourly.weather[index];\n    const date = +((new Date(hourly.date).getTime() / 1000).toFixed());\n\n    // https://gist.github.com/tbranyen/62d974681dea8ee0caa1\n    if (date >= sunrise && date < sunset) {\n        return `wi wi-owm-day-${weather.id}`;\n    } else if (date >= sunset || date < sunrise) {\n        return `wi wi-owm-night-${weather.id}`;\n    } else {\n        return '';\n    }\n};\n","import React, { useState } from 'react';\nimport axios from 'axios';\n\nimport { getHourlyIconClassName } from './WeatherIconsHelper';\nimport { useCron, shortTime } from '../../utility';\n\nimport './Weather.css';\n\nconst SERVER_BASE_URL = process.env.REACT_APP_SERVER_BASE_URL;\n\n/**\n * Componente che mostra il meteo.\n */\nfunction Weather() {\n    const [forecast, setForecast] = useState();\n\n    useCron(\n        '0 */30 * * * *',\n        async () => {\n            try {\n                const res = await axios.get(\n                    `${SERVER_BASE_URL}/weather/forecast`\n                );\n                const { sunrise, sunset, hourly } = res.data;\n                // considero il primo elemento di hourly come il meteo corente\n                // poi prendo i successivi 4 elementi\n                setForecast({\n                    current: {\n                        description: hourly[0].weather[0].description,\n                        icon: getHourlyIconClassName(\n                            hourly[0],\n                            sunrise,\n                            sunset\n                        ),\n                    },\n                    items: hourly.slice(1, 5).map((hour) => ({\n                        time: shortTime(new Date(hour.date)),\n                        icon: getHourlyIconClassName(hour, sunrise, sunset),\n                    })),\n                });\n                // TODO: mostrare la situazione peggiore da adesso alle prox 3 ore\n            } catch (e) {\n                console.error(e);\n                setForecast(null);\n            }\n        },\n        { runOnInit: true }\n    );\n\n    return (\n        <div className=\"weather box\">\n            {forecast ? (\n                <>\n                    <div className=\"weather-description marquee box-header text-center place-center text-uppercase text-ellipsis text-2x\">\n                        {forecast.current.description}\n                    </div>\n                    <div className=\"weather-icon place-center\">\n                        <i className={forecast.current.icon}></i>\n                    </div>\n                    <div className=\"weather-items\">\n                        {forecast.items.map((item, index) => (\n                            <div key={index}>\n                                <div>{item.time}</div>\n                                <i className={item.icon}></i>\n                            </div>\n                        ))}\n                    </div>\n                </>\n            ) : null}\n        </div>\n    );\n}\n\nexport default Weather;\n","import React, { useEffect, useState } from 'react';\nimport axios from 'axios';\n\nimport { formatDate, shortTime, parseDate, humanDate } from '../../utility';\n\nimport './WasteCollection.css';\n\nconst SERVER_BASE_URL = process.env.REACT_APP_SERVER_BASE_URL;\n// ora di termine ritiro rifiuti\nconst WASTE_COLLECTION_END_TIME = '10:00';\n// descrizione tipologia rifiuti\nconst WASTE_DESCR = {\n    P: 'Plastica',\n    C: 'Carta',\n    U: 'Umido',\n    V: 'Vetro',\n    S: 'Secco',\n};\n\n/**\n * Componente che mostra il prossimo ritiro dei rifiuti.\n * TODO: deve aggiornarsi dopo l'orario di ritiro rifiuti, verso le 10AM\n * TODO: aggiungere link a editor (importare da waste-collection-calendar)\n */\nfunction WasteCollection() {\n    const [waste, setWaste] = useState({});\n\n    useEffect(() => {\n        (async () => {\n            try {\n                const today = formatDate(new Date(), 'yyyyMMdd');\n                const now = shortTime();\n                // ritorna il ritiro per la data indicata (sempre) e il successivo (se c'è)\n                const res = await axios.get(\n                    `${SERVER_BASE_URL}/waste/${today}`\n                );\n                // ritorna un array\n                // come primo elemento la data richiesta\n                // come seoncdo il ritiro successivo alla data richiesta, se esiste\n                const { data } = res;\n                // console.log(data);\n\n                // se non è ancora passata l'ora del ritiro cerco oggi\n                const index =\n                    now <= WASTE_COLLECTION_END_TIME && data[0] ? 0 : 1;\n                if (data[index]) {\n                    // data[index].waste = 'S';\n                    setWaste({\n                        title: humanDate(parseDate(data[index].date)), // TODO: formattare\n                        items: data[index].waste.split('').map((wt) => ({\n                            icon: 'waste-icon-' + wt,\n                            type: wt,\n                            description: WASTE_DESCR[wt],\n                        })),\n                    });\n                } else {\n                    setWaste({\n                        title: 'NULLA',\n                        itmes: [],\n                    });\n                }\n            } catch (e) {\n                console.error(e);\n            }\n        })();\n    }, []);\n\n    return (\n        <div className=\"waste-collection box\">\n            <div className=\"box-header text-center place-center text-uppercase text-ellipsis text-2x\">\n                {waste.title}\n            </div>\n            <div className=\"item-container\">\n                {waste.items &&\n                    waste.items.map((item, index) => (\n                        <div key={index} className=\"item\">\n                            <div className=\"descr text-uppercase\">\n                                {item.description}\n                            </div>\n                            <div className=\"icon\">\n                                <div\n                                    className=\"waste-icon\"\n                                    type={item.type}\n                                ></div>\n                            </div>\n                        </div>\n                    ))}\n            </div>\n        </div>\n    );\n}\n\nexport default WasteCollection;\n","import React from 'react';\n\nimport Calendar from '../calendar/Calendar';\nimport Weather from '../weather/Weather';\nimport WasteCollection from '../wastecollection/WasteCollection';\n\nimport './App.css';\n\nfunction App() {\n    return <div className=\"app\">\n      <main>\n          <WasteCollection />\n          <Weather />\n      </main>\n      <footer>\n        <Calendar />\n      </footer>\n    </div>;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/app/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}